/**
 * generated by Xtext
 */
package cl.uchile.pleiad.generator;

import ca.mcgill.cs.sel.ram.Aspect;
import cl.uchile.pleiad.converter.ModelConverterProxy;
import cl.uchile.pleiad.textRam.TAspect;
import cl.uchile.pleiad.textRam.TInstantiationHeader;
import cl.uchile.pleiad.util.DirectedGraph;
import cl.uchile.pleiad.util.TextRAMPersistence;
import cl.uchile.pleiad.util.TopologicalSort;
import com.google.common.collect.Iterables;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
@SuppressWarnings("all")
public class TextRAMGenerator implements IGenerator {
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    final DirectedGraph<TAspect> d = new DirectedGraph<TAspect>();
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
    Iterable<TAspect> _filter = Iterables.<TAspect>filter(_iterable, TAspect.class);
    for (final TAspect aspect : _filter) {
      this.addNode(d, ((TAspect) aspect));
    }
    ModelConverterProxy _instance = ModelConverterProxy.getInstance();
    _instance.reset();
    List<TAspect> _sort = TopologicalSort.<TAspect>sort(d);
    final Procedure1<TAspect> _function = new Procedure1<TAspect>() {
      public void apply(final TAspect aspect) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("aspects/");
        String _name = aspect.getName();
        _builder.append(_name, "");
        _builder.append(".ram");
        final String relativePath = _builder.toString();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("../aspects/");
        String _name_1 = aspect.getName();
        _builder_1.append(_name_1, "");
        _builder_1.append(".ram");
        final String path = _builder_1.toString();
        ModelConverterProxy _instance = ModelConverterProxy.getInstance();
        final Aspect ramAspect = _instance.convertTextRAMModelToRAMModel(aspect);
        TextRAMPersistence _instance_1 = TextRAMPersistence.getInstance();
        final String content = _instance_1.serializeModel(ramAspect, path);
        fsa.generateFile(relativePath, content);
      }
    };
    IterableExtensions.<TAspect>forEach(_sort, _function);
  }
  
  public void addNode(final DirectedGraph<TAspect> d, final TAspect aspect) {
    d.addNode(aspect);
    final TAspect textRamAspect = ((TAspect) aspect);
    EList<TInstantiationHeader> _headerInstantiations = textRamAspect.getHeaderInstantiations();
    final Procedure1<TInstantiationHeader> _function = new Procedure1<TInstantiationHeader>() {
      public void apply(final TInstantiationHeader instantiation) {
        EList<TAspect> _externalAspects = instantiation.getExternalAspects();
        final Procedure1<TAspect> _function = new Procedure1<TAspect>() {
          public void apply(final TAspect externalAspect) {
            d.addNode(externalAspect);
            d.addEdge(externalAspect, aspect);
            TextRAMGenerator.this.addNode(d, externalAspect);
          }
        };
        IterableExtensions.<TAspect>forEach(_externalAspects, _function);
      }
    };
    IterableExtensions.<TInstantiationHeader>forEach(_headerInstantiations, _function);
  }
}
