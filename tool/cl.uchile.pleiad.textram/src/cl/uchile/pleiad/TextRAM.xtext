grammar cl.uchile.pleiad.TextRAM with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://cs.mcgill.ca/sel/ram/2.1"

generate textRam "http://cl.pleiad.textram/1.0" as textRam

Aspect returns Aspect:
'aspect'
name=EString
'{'
	structuralView=TStructuralView
	('instantiations' '{' instantiations+=Instantiation ( ";"? instantiations+=Instantiation)* '}' )?
	('messages' '{' messageViews+=TAbstractMessageView '}' )?
'}';

terminal TEMPLATE: (ID'<' ID '>')*;
terminal PARTIAL_STRING: ('|'ID)*;
EString returns ecore::EString:
    STRING | ID | TEMPLATE | PARTIAL_STRING | '<<' | '>>';

EInt returns ecore::EInt:
    '-'? INT;
    
ReferenceType returns ReferenceType:
    'ReferenceType' /* TODO: implement this rule and an appropriate IValueConverter */;    

AbstractStructuralView returns StructuralView:
    TStructuralView
;

TAbstractMessageView returns AbstractMessageView:
	{textRam::TAbstractMessageView}		
	'objects' '{'
		lifelines+=TLifeline (';'? lifelines+=TLifeline)*
	'}'
	
	messages+=TAbstractMessages (messages+=TAbstractMessages)*
;

TAbstractMessages returns textRam::TAbstractMessages:
	TMessageView
;

TStructuralView returns textRam::TStructuralView:
    {textRam::TStructuralView}
    'structure'
    '{'
        ( classes+=Classifier (classes+=Classifier)* )?
        ('associations' '{' tAssociations+=TAssociation ( ";"? tAssociations+=TAssociation)* '}' )?
    '}';
        
Classifier returns Classifier:
    TClass;

Type returns Type:
    TClass | RVoid | RBoolean | RInt | RChar | RString | RAny |  RDouble | RFloat | RSet;

ObjectType returns ObjectType:
    TClass | RBoolean | RInt | RChar | RString | RSet | RDouble | RFloat;    
        
PrimitiveType returns PrimitiveType:
    RBoolean | RInt | RChar | RString | RDouble | RFloat;// | REnum;

RString: {RString}; 

RFloat: {RFloat};

RDouble: {RDouble};

RAny: {RAny};

RChar: {RChar};

RInt: {RInt};

RBoolean: {RBoolean};

RVoid: {RVoid};

RSet: {RSet};

AbstractClass returns Class:
	TClass
;

TClassMember returns textRam::TClassMember:
	TAttribute | TOperation
;
  
TClass returns textRam::TClass:
    {textRam::TClass}
    (abstract?='abstract')?
    'class'
    name=EString (':' superTypes+=[Classifier|EString])?
    '{'
    	( members+=TClassMember  ( ";"? members+= TClassMember)*  )?
    '}';

TAttribute returns textRam::TAttribute:
    {textRam::TAttribute}
    (static?='static')?
    type=[PrimitiveType|EString]
    name=EString;

TOperation returns textRam::TOperation:
    {textRam::TOperation}
    (abstract?='abstract')?
    (static?='static')?
    visibility=Visibility
    returnType=[Type|EString]
    name=EString 
    '('
    	( parameters+=Parameter ( "," parameters+=Parameter)* )?
    ')';
    
StructuralFeature returns textRam::TStructuralFeature:
	TAssociation | TAttribute //TODO: | Reference 
;

Parameter returns Parameter:
    {Parameter}
    type=[Type|EString]
    name=EString;  

enum Visibility returns Visibility:
	public = '+' | private = '-' | protected = '#' | package = "~" 
;

TAssociation returns textRam::TAssociation:
    {textRam::TAssociation}
    fromEnd=TAssociationEnd "->" toEnd=TAssociationEnd  '{' name=EString  '}'  
;

TAssociationEnd returns textRam::TAssociationEnd:
	{textRam::TAssociationEnd}
    (lowerBound=ElementBound
    '..')?
    (upperBound=ElementBound)?
    classReference=[Class|EString]
;

ElementBound returns ecore::EInt:
	'*' | INT;
	
Instantiation returns Instantiation:
    (type=InstantiationType)?
    externalAspect=[Aspect|EString]
    ('{' mappings+=TClassifierMapping ( ";"? mappings+=TClassifierMapping)* '}' )
;
    
enum InstantiationType returns InstantiationType:
    Depends = 'dependsOn' | Extends = 'extends';
    

AbstractClassifierMapping returns ClassifierMapping:
    TClassifierMapping
; 

TClassifierMapping returns textRam::TClassifierMapping:
    fromElement=[Classifier|EString] ('<' fromMember+=[textRam::TClassMember] ("," fromMember+=[textRam::TClassMember])* '>')?
    '->'
    toElement=[Classifier|EString] ('<' toMember+=[textRam::TClassMember] ("," toMember+=[textRam::TClassMember])*  '>')?
;

TMessageView returns textRam::TMessageView:
	{textRam::TMessageView}
	'messageView' class=[textRam::TClass|EString] '.' specifies=[textRam::TOperation|EString] 
	'('
    	( parameters+=Parameter ( "," parameters+=Parameter)* )?
    ')'
	'{'
		specification=TInteraction
	'}'
;

TInteraction returns textRam::TInteraction:
	interactionMessages+=TInteractionMessage (';'? interactionMessages+=TInteractionMessage)*
;


TLifeline returns textRam::TLifeline:
	name=EString (':' represents=[textRam::TTypedElement|EString])?
;

TInteractionMessage returns textRam::TInteractionMessage:
	leftLifeline=[textRam::TLifeline|EString] '=>' rightLifeline=[textRam::TLifeline|EString] '{'  message=TAbstractMessage  '}'
;

TAbstractMessage returns textRam::TAbstractMessage:
	TMessage | TOperationSignature
;

TMessage returns textRam::TMessage:
	(assignTo=[textRam::TStructuralFeature|EString] ':=')?
	signature=[textRam::TOperation|EString] '(' ( arguments+=[Parameter|EString] (',' arguments+=[Parameter|EString] )?  )? ')'
;

TOperationSignature returns textRam::TOperationSignature:
	signature=[textRam::TOperation|EString]
	'('
    	( parameters+=Parameter ( "," parameters+=Parameter)* )?
    ')'
    ':'
    returnType=[Type|EString]
;

//TODO: It should be StructuralFeature | Parameter
TTypedElement returns textRam::TTypedElement:
	TAssociation | TAttribute | TClass
;

enum MessageSort returns MessageSort:
    synchCall = 'synchCall' | createMessage = 'createMessage' | deleteMessage = 'deleteMessage' | reply = 'reply'
;