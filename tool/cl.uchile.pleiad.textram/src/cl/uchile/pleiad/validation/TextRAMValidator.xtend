/*
 * generated by Xtext
 */
package cl.uchile.pleiad.validation

import ca.mcgill.cs.sel.ram.Aspect
import ca.mcgill.cs.sel.ram.Class
import ca.mcgill.cs.sel.ram.RamPackage
import cl.uchile.pleiad.textRam.TAbstractMessages
import cl.uchile.pleiad.textRam.TAssociation
import cl.uchile.pleiad.textRam.TClass
import cl.uchile.pleiad.textRam.TClassifierMapping
import cl.uchile.pleiad.textRam.TInteractionMessage
import cl.uchile.pleiad.textRam.TLifeline
import cl.uchile.pleiad.textRam.TLifelineReferenceType
import cl.uchile.pleiad.textRam.TLocalAttribute
import cl.uchile.pleiad.textRam.TMessage
import cl.uchile.pleiad.textRam.TOperation
import cl.uchile.pleiad.textRam.TParameterValue
import cl.uchile.pleiad.textRam.TReference
import cl.uchile.pleiad.textRam.TextRamPackage
import cl.uchile.pleiad.util.TextRamEcoreUtil
import java.util.List
import org.eclipse.xtext.validation.Check

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class TextRAMValidator extends AbstractTextRAMValidator {

	@Check
	def checkOperationIsValidOnInteraction(TMessage tMessage){
		val tInteraction = tMessage.eContainer as TInteractionMessage
		
		// check operation signature
		var TClass clazz = null
		val operation = tMessage.signature
		val arguments = tMessage.arguments
		
		val List<TOperation> operations = newArrayList
		
		if (tInteraction.rightLifeline.referenceType == TLifelineReferenceType.REFERENCE) {
			clazz = tInteraction.rightLifeline.represents as TClass
		}
		
		if (tInteraction.rightLifeline.referenceType == TLifelineReferenceType.ASSOCIATION) {
			clazz = (tInteraction.rightLifeline.represents as TAssociation).toEnd.classReference as TClass
		}
		
		if (tInteraction.rightLifeline.referenceType == TLifelineReferenceType.ASSOCIATION) {
			throw new Exception("Attributes not supported as TLifeline references")
		}
		
		operations.addAll( TextRamEcoreUtil.findOperations( clazz, operation.name) )
			
		// error if the operation doesn't exists
		if (operations.length == 0) {
			error('The operation ' + operation.name + ' is undefined for the class ' + clazz.name, TextRamPackage.Literals.TMESSAGE__ARGUMENTS)
		}
			
		// there is no operation's overloading
		if ( operations.length == 1 ) {
			if (operations.get(0).parameters.length != arguments.length ) {
				error('Invalid number of arguments on ' + operation.name, TextRamPackage.Literals.TMESSAGE__ARGUMENTS)
			}
		
			// check arguments's type
			if (operations.get(0).parameters.length > 0) { 
				for ( Integer i: 0..operations.get(0).parameters.size - 1) {
					if ( arguments.get(i).typeNameForTValueSpecification != operations.get(0).parameters.get(i).type.name ) {
						error('Type mismatch: cannot convert from  ' + arguments.get(i).typeNameForTValueSpecification + ' to ' + operations.get(0).parameters.get(i).type.name, TextRamPackage.Literals.TABSTRACT_MESSAGES__ARGUMENTS)
					}
				}
			}
		}
		
		// there is operation's overloading
		if ( operations.length > 1 ) {
			var matchSignature = false
			
			// check the operation's signature
			for ( o : operations ) {

				if (matchSignature == false) {
					// check operation's length
					if ( o.parameters.length == arguments.length ) {
						
						var matchParametersType = true
						for ( Integer i: 0..o.parameters.size - 1) {
							if ( o.parameters.get(i).type.name != arguments.get(i).typeNameForTValueSpecification ) {
								matchParametersType = false
							}
						}
						
						if (matchParametersType == true) {
							matchSignature = true
						}
					}
				}
			}
			
			if (matchSignature == false) {
				error('The operation ' + operation.name + ' has invalid arguments ', TextRamPackage.Literals.TMESSAGE__ARGUMENTS)
			}		
		
		}
	}
	
	private def dispatch getTypeNameForTValueSpecification(TLocalAttribute specification) {
		specification.type.name
	}
	
	private def dispatch getTypeNameForTValueSpecification(TReference specification) {
		(specification.reference as TClass).name
	}
	
	private def dispatch getTypeNameForTValueSpecification(TParameterValue specification) {
		specification.name
	}
	
	private def dispatch getTypeNameForTValueSpecification(TLifeline l) {
		if (l.referenceType != TLifelineReferenceType.REFERENCE) {
			throw new Exception("Only Reference types can be parameters");
		}
		
		(l.represents as TClass).name
	}

	@Check
	def checkOperationIsValidOnMessageView(TAbstractMessages messageView) {
		
		// check if class has been defined
		val clazz = messageView.class_ 
		val operation = messageView.specifies
		val arguments = messageView.arguments
		
		val List<TOperation> operations = newArrayList 
		
		// check if the operation has been defined in the class
		if (clazz != null) {
			operations.addAll( TextRamEcoreUtil.findOperations(clazz,  operation.name) )
		}
		else {
			val Aspect aspect = TextRamEcoreUtil.getRootContainerOfType( messageView, RamPackage.Literals.ASPECT ) 
			operations.addAll(aspect.structuralView.classes.filter(TClass).map[members].flatten.filter(TOperation).filter( o | o.name == operation.name ).toList)
			
			if (operations.length > 1) {
				error('ambiguity in operation definition', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
			}
		}
		

		// error if the operation doesn't exists
		if (operations.length == 0) {
			error('The operation ' + operation.name + ' is undefined for the class ' + clazz.name, TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
		}
		
		// there is no operation's overloading
		if ( operations.length == 1 ) {
			if (operations.get(0).parameters.length != arguments.length ) {
				error('Invalid number of arguments on ' + operation.name, TextRamPackage.Literals.TABSTRACT_MESSAGES__ARGUMENTS)
			}
		
			// check arguments's type
			if (operations.get(0).parameters.length > 0) { 
				for ( Integer i: 0..operations.get(0).parameters.size - 1) {
					if ( arguments.get(i).type.name != operations.get(0).parameters.get(i).type.name ) {
						error('Type mismatch: cannot convert from  ' + arguments.get(i).type.name + ' to ' + operations.get(0).parameters.get(i).type.name, TextRamPackage.Literals.TABSTRACT_MESSAGES__ARGUMENTS)
					}
				}
			}
		}
		
		// there is operation's overloading
		if ( operations.length > 1 ) {
			var matchSignature = false
			
			// check the operation's signature
			for ( o : operations ) {

				if (matchSignature == false) {
					// check operation's length
					if ( o.parameters.length == arguments.length ) {
						
						var matchParametersType = true
						for ( Integer i: 0..o.parameters.size - 1) {
							if ( o.parameters.get(i).type.name != arguments.get(i).type.name ) {
								matchParametersType = false
							}
						}
						
						if (matchParametersType == true) {
							matchSignature = true
						}
					}
				}
			}
			
			if (matchSignature == false) {
				error('The operation ' + operation.name + ' has invalid arguments ', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
			}		
		}
	
	}
	
	@Check
	def checkPartialDefinitionsOnTAbstractMessages(TAbstractMessages messageView) {
		val clazz = messageView.class_
		val operation = messageView.specifies
		
		if (clazz != null && clazz.partial != messageView.partialClass) {
			if (clazz.partial == true) {
				error('The class ' + clazz.name +' has to be defined as partial.', TextRamPackage.Literals.TABSTRACT_MESSAGES__CLASS)
			}
			else {
				error('The class ' + clazz.name + ' is not a partial class.' , TextRamPackage.Literals.TABSTRACT_MESSAGES__CLASS)
			}
		}
		
		if (operation != null && operation.partial != messageView.partialOperation) {
			if (operation.partial == true) {
				error('The operation ' + operation.name +' has to be defined as partial.', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
			}
			else {
				error('The operation ' + operation.name + ' is not a partial operation.' , TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
			}
		}		
	}
	
	@Check
	def checkPartialDefinitionOnReference(TReference reference) {
		if (reference.partialClass == false && reference.reference.partial == true) {
			error('The class ' + reference.reference.name + ' has to be defined as partial.', TextRamPackage.Literals.TREFERENCE__REFERENCE )
		}
		
		if (reference.partialClass == true && reference.reference.partial == false ) {
			error('The class ' + reference.reference.name + ' is not a partial class.', TextRamPackage.Literals.TREFERENCE__REFERENCE ) 
		}
	}
	
	@Check
	def checkPartialDefinitionOnTMessageWithSignature(TMessage message) {
		if (message.partialOperation == false && message.signature.partial == true) {
			error('The class ' + message.signature.name + ' has to be defined as partial.', TextRamPackage.Literals.TMESSAGE__SIGNATURE )
		}
		
		if (message.partialOperation == true && message.signature.partial == false) {
			error('The class ' + message.signature.name + ' is not a partial class.', TextRamPackage.Literals.TMESSAGE__SIGNATURE) 
		}
	}
	
	@Check
	def checkPartialDefinitionOnTClassifierMapping(TClassifierMapping classifierMapping) {
		if ( classifierMapping.partialFromElement == false &&  (classifierMapping.fromElement as Class).partial == true) {
			error('The class ' + classifierMapping.fromElement.name + ' has to be defined as partial (fromElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_FROM_ELEMENT )
		}
		
		if ( classifierMapping.partialFromElement == true &&  (classifierMapping.fromElement as Class).partial == false) {
			error('The class ' + classifierMapping.fromElement.name + ' is not a partial class (fromElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_FROM_ELEMENT )
		}
		
		if ( classifierMapping.partialToElement == false &&  (classifierMapping.toElement as Class).partial == true) {
			error('The class ' + classifierMapping.toElement.name + ' has to be defined as partial (toElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_TO_ELEMENT )
		}
		
		if ( classifierMapping.partialToElement == true &&  (classifierMapping.toElement as Class).partial == false) {
			error('The class ' + classifierMapping.toElement.name + ' is not a partial class (toElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_TO_ELEMENT )
		}
	}
}