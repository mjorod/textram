/*
 * generated by Xtext
 */
package cl.uchile.pleiad.validation

import ca.mcgill.cs.sel.ram.Aspect
import ca.mcgill.cs.sel.ram.Class
import ca.mcgill.cs.sel.ram.RamPackage
import cl.uchile.pleiad.textRam.TAbstractMessageView
import cl.uchile.pleiad.textRam.TAbstractMessages
import cl.uchile.pleiad.textRam.TAspect
import cl.uchile.pleiad.textRam.TAssociation
import cl.uchile.pleiad.textRam.TAttribute
import cl.uchile.pleiad.textRam.TClass
import cl.uchile.pleiad.textRam.TClassifierMapping
import cl.uchile.pleiad.textRam.TInteractionMessage
import cl.uchile.pleiad.textRam.TLifeline
import cl.uchile.pleiad.textRam.TLifelineReferenceType
import cl.uchile.pleiad.textRam.TLocalAttribute
import cl.uchile.pleiad.textRam.TMessage
import cl.uchile.pleiad.textRam.TOperation
import cl.uchile.pleiad.textRam.TParameter
import cl.uchile.pleiad.textRam.TReference
import cl.uchile.pleiad.textRam.TStructuralView
import cl.uchile.pleiad.textRam.TValueSpecification
import cl.uchile.pleiad.textRam.TextRamPackage
import java.util.List
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.validation.Check
import cl.uchile.pleiad.util.TextRamEcoreUtil

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class TextRAMValidator extends AbstractTextRAMValidator {

    public static val DUPLICATE_ELEMENT = "cl.uchile.pleiad.DuplicateElement"
    
    public static val DUPLICATE_CLASS = "cl.uchile.pleiad.DuplicateClass"
    
    @Check
    def checkNoDuplicatesAttributes(TAttribute attr) {
     	val owner = TextRamEcoreUtil.getRootContainerOfType(attr, TextRamPackage.Literals.TCLASS) as TClass;
    	
    	val count = owner.members.filter( m | m.name == attr.name ).size
    	
    	if ( count > 1 ) {
    		error('''Duplicate member '« attr.name »' ''',TextRamPackage.eINSTANCE.TClassMember_Name, DUPLICATE_ELEMENT)
    	}
    }
    
    @Check
    def checkNoDuplicationOperations(TOperation operation) {
    	val owner = TextRamEcoreUtil.getRootContainerOfType(operation, TextRamPackage.Literals.TCLASS) as TClass;
    	
    	// get all operations with the same name and the same paramter's length
    	val operations = owner.members.filter(TOperation).filter( o | o.name == operation.name 
    		&& o.parameters.size == operation.parameters.size)
    	
    	var error = false
    	
    	// check for parameter's types
    	val List<String> parameterTypesList = newArrayList
    	for ( o : operations ) {
    		var parameterTypes = o.parameters.stringifyTypes(); 
    		
    		if ( error == false && parameterTypesList.contains(parameterTypes) == false ) {
    			parameterTypesList.add(parameterTypes)
    		}
    		else {
    			error = true
    			error('''Duplicate member '« o.name »' ''', TextRamPackage.eINSTANCE.TClassMember_Name, DUPLICATE_ELEMENT)
    		}
    	}
    }
	
	/**
	 * converts to string each parameter's type and creates a concatenated string  
	 * @ parameters list of parameters
	 */
	private def stringifyTypes(EList<TParameter> parameters){
		var result = "" 
		for ( p : parameters ) {
    			result = result.concat(p.type.name)
    	}
    	
    	result
	}
    
   
    @Check
    def checkNoDuplicateClass(TClass clazz) {
		val owner = TextRamEcoreUtil.getRootContainerOfType(clazz, TextRamPackage.Literals.TASPECT) as TAspect;
		
		val count = (owner.structuralView as TStructuralView).classes.filter(TClass).filter( c | c.name == clazz.name ).size
		
		if (count > 1) {
			error ('''Duplicate class '« clazz.name »' ''', RamPackage.eINSTANCE.namedElement_Name, DUPLICATE_CLASS)
		}
   
    }
    
    @Check
    def checkOperationFromMessageViewExistsOnClass(TMessage tMessage) {
    	val textRamInteraction = tMessage.eContainer as TInteractionMessage
    	
    	// gets the operation from message view
		val messageArgumentsge.signature
		

		// owner of the operation
		val owner = textRamInteraction.getTextRamClass
		
		if ( owner.containsOperation(operation) == false ) {
			error('The operation ' + operation.name + ' is undefined', TextRamPackage.Literals.TMESSAGE__SIGNATURE)
		}
    } 
    
//Check
//ef checkOperationIsValidOnInteraction(TMessage tMessage){
//// cast to textRamInteraction		
//val textRamInteraction = tMessage.eContainer as TInteractionMessage
//
//// gets the operation from message view
//val operation = tMessage.signature
//
//// gets operation's arguments
//val operationArguments = tMessage.arguments
//
//// ownmessageArgumentsn
//		l owner = textRamInteraction.getTextRamClass
//		/		 ( owner.containsOperation(operation) == false ) {
//		rror('''T'operation '«ope + operation.name +  undefined''','xtRamPackage.Literals.TMESSAGE__SIGNATURE, ME}
		
/	//ll methods from the owner class that match operation's name
//		vaoperations = TextRamEcoreUtil.findTextRamOperations( owner, operation.name)
//		
/	//here is no operation's overloading
//		if operations.areOverloaded == false ) {
//			v currentOperation = operations.get(0)
//messeArgentsSameNumberOfArgumentsOnMessageInteraction( currentOperation.parameters, operationArguments ) == false ) {
//				err('Invalid number of arguments on ' + operation.name, TextRamPackage.Literals.TMESSAGE__ARGUMENTS)
//			}
/		
//	if haveSameArgumentsTypeOnMessageInteraction( currentOperation.parameters, operationArguments ) == false ) {
//				//DO: which parameter?
//				err('Type mismatch: cannot convert from parameters', TextRamPackage.Literals.TMESSAGE__ARGUMENTS)
//			}
///		}/	else
//			// ere is operation overloading
//			val = operations.findOperationThatMatchArgumentsSignatureOnMessageInteraction( operationArguments )
//			if o == null) {
//				err('The operation ' + operation.name + ' has invalid arguments ', TextRamPackage.Literals.TMESSAGE__SIGNATURE)
//			}
/	}		
	}
//	/	d ctainsOperation(TClass clazz, TOperation operation) {
//		retu clazz.members.filter(TOperation).exists[ o | o.name == operation.name ]
//	}
	
	heck
	def checkOperationIsValidOnMessageView(TAbstractMessages messageView) {
		
		val clazz = messageView.class_ 
		val messageViewOperation = messageView.specifies
		val messageViewArguments = messageView.arguments

		val Aspect aspect = TextRamEcoreUtil.getRootContainerOfType( messageView, RamPackage.Literals.ASPECT ) 

		val List<TOperation> operations = aspect.getAllOperations(clazz, messageViewOperation.name) 		

		if (operations.empty == true) {
			error('The operation ' + messageViewOperation.name + ' is undefined', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
			return
		}

		// if the operation's name has many occurrences inside the structural view, the user must to define the class name.
		if ( operations.haveAmbiguityDefinition == true ) {
				error('There are more than one operation with the same name. You have to define the class owner of the operation.', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
				return
		}
				
		if ( operations.areOverloaded == false ) {
			val currentOperation = operations.get(0)
			
			if ( haveSameNumberOfArguments( currentOperation.parameters, messageViewArguments ) == false ) {
				error('Invalid number of arguments on ' + messageViewOperation.name, TextRamPackage.Literals.TABSTRACT_MESSAGES__ARGUMENTS)
				return				
			}
			
			if ( haveSameArgumentsType( currentOperation.parameters, messageViewArguments ) == false ) {
				//TODO: which parameter?
				error('Type mismatch: cannot convert from parameters', TextRamPackage.Literals.TABSTRACT_MESSAGES__ARGUMENTS)
				return		
			}
		} 
		else {
			// there is operation overloading
			val o = operations.findOperationThatMatchArgumentsSignature( messageViewArguments )
			if ( o == null) {
				error('The operation ' + messageViewOperation.name + ' has invalid arguments ', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
				return
			}
		}
	
	}
	
	/**
	 * Gets the class from a {@link TInteractionMessage interaction}. 
	 * Evaluates the rightlifeline's referenceType attribute and resolves how to get the corresponded class.
	 * 
	 * @param textRamInteraction current message interaction
	 * @return {@link TClass class} owner f the message interaction
	 */
	private def getTextRamClass(TInteractionMessage textRamInteraction) {
		var TClass result = null
		
		if (textRamInteraction.rightLifeline.referenceType == TLifelineReferenceType.REFERENCE) {
			result = textRamInteraction.rightLifeline.represents as TClass
		}
		
		if (textRamInteraction.rightLifeline.referenceType == TLifelineReferenceType.ASSOCIATION) {
			result = (textRamInteraction.rightLifeline.represents as TAssociation).toEnd.classReference as TClass
		}
		
		if (textRamInteraction.rightLifeline.referenceType == TLifelineReferenceType.ATTRIBUTE) {
			throw new Exception("Attributes are not supported as TLifeline references")
		}
		
		result
	}
	
	private def getAllOperations(Aspect aspect, TClass optionalClass, String operationName) {
		val List<TOperation> result = newArrayList
		
		if ( optionalClass.isDefined ) {
			result.addAll( TextRamEcoreUtil.findTextRamOperations(optionalClass, operationName) )
		}
		else {
			result.addAll ( TextRamEcoreUtil.findAspectOperations( aspect, operationName ) )
		}
		
		result
	}
	
	private def findOperationThatMatchArgumentsSignatureOnMessageInteraction(List<TOperation> operations, EList<TValueSpecification> arguments) {
		var TOperation result = null
		
		for ( o : operations ) {
			if ( haveSameNumberOfArgumentsOnMessageInteraction( o.parameters, arguments ) == true &&
				 haveSameArgumentsTypeOnMessageInteraction( o.parameters, arguments ) == true ) {
				result = o
			}			
		}
		
		result 
	}
	
	private def findOperationThatMatchArgumentsSignature(List<TOperation> operations, EList<TParameter> arguments) {
		var TOperation result = null
		
		for ( o : operations ) {
			if ( haveSameNumberOfArguments( o.parameters, arguments ) == true &&
				 haveSameArgumentsType( o.parameters, arguments ) == true ) {
				result = o
			}			
		}
		
		result 
	}
	
	private def dispatch getTypeNameForTValueSpecification(TLocalAttribute specification) {
		specification.type.name
	}
	
	private def dispatch getTypeNameForTValueSpecification(TReference specification) {
		(specification.reference as TClass).name
	}
	
	private def dispatch getTypeNameForTValueSpecification(TParameter specification) {
		specification.type.name
	}
	
	private def dispatch getTypeNameForTValueSpecification(TLifeline l) {
		if (l.referenceType != TLifelineReferenceType.REFERENCE) {
			throw new Exception("Only Reference types can be parameters");
		}
		
		(l.represents as TClass).name
	}
	
	private def haveSameArgumentsTypeOnMessageInteraction(EList<TParameter> list, EList<TValueSpecification> list2) {
		// assumes both lists have the same size
		if (list.size != list2.size) {
			throw new Exception("Argument's lists are not the same size")
		}
		
		if ( list.empty == false && list2.empty == false ) {
			for ( Integer i: 0..list.size - 1) {
				if ( list.get(i).type.name != list2.get(i).typeNameForTValueSpecification) {
					return false;
				}
			}
		}
				
		return true;
	}
	
	private def haveSameArgumentsType(EList<TParameter> list, EList<TParameter> list2) {
		// assumes both lists have the same size
		if (list.size != list2.size) {
			throw new Exception("Argument's lists are not the same size")
		}
		
		if ( list.empty == false && list2.empty == false ) {
			for ( Integer i: 0..list.size - 1) {
				if ( list.get(i).type.name != list2.get(i).type.name ) {
					return false;
				}
			}
		}
		
		return true;
	}
	
	private def haveSameNumberOfArguments(EList<TParameter> list, EList<TParameter> list2) {
		return list.size == list2.size
	}
	
	/**
	 * check if the quantity of arguments of two lists are the same.
	 * This method is used to validate the quantity of arguments between a class's operation and message view header's operation.
	 * 
	 * @param list one to compare
	 * @param list two to compare
	 * @return returns true if both lists have the same number of elements, otherwise returns false.
	 */
	private def haveSameNumberOfArgumentsOnMessageInteraction(EList<TParameter> list, EList<TValueSpecification> list2) {
		return list.size == list2.size
	} 
	
	/**
	 * check if the operation is overloaded
	 * 
	 * @param operations from a class
	 * @return retuns true if exists overloading, otherwise returns false.
	 */
	private def areOverloaded(List<TOperation> operations) {
		return operations.size > 0
	}
	
	/**
	 * There is ambiguity if the operation has more than one occurrence. 
	 * This method is used to check if the message view header's operation needs the class definition to avoid ambiguity.
	 * 
	 * @param operations extracted from the structural view
	 * @return returns true if exists ambiguity, otherwise returns false.
	 */
	private def haveAmbiguityDefinition(List<TOperation> operations) {
		return operations.size > 1
	}
	
	private def isDefined(TClass clazz) {
		return clazz != null;
	}
	
	@Check
	def checkPartialDefinitionForTOperationReturnType(TOperation operation){
		if (operation.returnType instanceof TClass) {
			val returnType = operation.returnType as TClass
			if (returnType.partial == true && operation.partialReturnType == false) {
				error('Missing | at ' + operation.returnType.name, TextRamPackage.Literals.TOPERATION__RETURN_TYPE)
			}
			
			if (returnType.partial == false && operation.partialReturnType == true) {
				error(operation.returnType.name + ' is not defined as partial', TextRamPackage.Literals.TOPERATION__RETURN_TYPE)
			}
		}
	}
	
	@Check 
	def checkPartialDefinitionForSuperTypes(TClass clazz) {
		clazz.superTypes.filter(TClass).forEach[ s | 
			if (clazz.partialSuperType == false && s.partial == true ) {
				error('Missing | at ' + s.name, RamPackage.Literals.CLASS__SUPER_TYPES)
			}
			
			if (clazz.partialSuperType == true && s.partial == false ) {
				error(s.name + ' is not defined as partial', RamPackage.Literals.CLASS__SUPER_TYPES)
			}
		]
	}
	
	@Check
	def checkPartialDefinitionForTParameterType(TParameter parameter) {
		if (parameter.type instanceof TClass) {
			val returnType = parameter.type as TClass
			if (returnType.partial == true && parameter.partialType == false) {
				error('Missing | at ' + parameter.type.name, TextRamPackage.Literals.TPARAMETER__TYPE)
			}
			
			if (returnType.partial == false && parameter.partialType == true) {
				error(parameter.type.name + ' is not defined as partial', TextRamPackage.Literals.TPARAMETER__TYPE)
			}
		}
	}
	
	@Check
	def checkPartialDefinitionsOnTAbstractMessages(TAbstractMessages messageView) {
		val clazz = messageView.class_
		val operation = messageView.specifies
		
		if (clazz != null && clazz.partial != messageView.partialClass) {
			if (clazz.partial == true) {
				error('Missing | at ' + clazz.name, TextRamPackage.Literals.TABSTRACT_MESSAGES__CLASS)
			}
			else {
				error('The class ' + clazz.name + ' is not a partial class.' , TextRamPackage.Literals.TABSTRACT_MESSAGES__CLASS)
			}
		}
		
		if (operation != null && operation.partial != messageView.partialOperation) {
			if (operation.partial == true) {
				error('Missing | at ' + operation.name, TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
			}
			else {
				error('The operation ' + operation.name + ' is not a partial operation.' , TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
			}
		}		
	}
	
	@Check
	def checkPartialDefinitionOnReference(TReference reference) {
		if (reference.partialClass == false && reference.reference.partial == true) {
			error('Missing | at ' + reference.reference.name, TextRamPackage.Literals.TREFERENCE__REFERENCE )
		}
		
		if (reference.partialClass == true && reference.reference.partial == false ) {
			error('The class ' + reference.reference.name + ' is not a partial class.', TextRamPackage.Literals.TREFERENCE__REFERENCE ) 
		}
	}
	
	@Check
	def checkPartialDefinitionOnTMessageWithSignature(TMessage message) {
		if (message.partialOperation == false && message.signature.partial == true) {
			error('Missing | at ' + message.signature.name, TextRamPackage.Literals.TMESSAGE__SIGNATURE )
		}
		
		if (message.partialOperation == true && message.signature.partial == false) {
			error('The class ' + message.signature.name + ' is not a partial class.', TextRamPackage.Literals.TMESSAGE__SIGNATURE) 
		}
	}
	
	@Check
	def checkPartialDefinitionOnTClassifierMapping(TClassifierMapping classifierMapping) {
		if ( classifierMapping.partialFromElement == false &&  (classifierMapping.fromElement as Class).partial == true) {
			error('Missing | at ' + classifierMapping.fromElement.name, TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_FROM_ELEMENT )
		}
		
		if ( classifierMapping.partialFromElement == true &&  (classifierMapping.fromElement as Class).partial == false) {
			error('The class ' + classifierMapping.fromElement.name + ' is not a partial class (fromElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_FROM_ELEMENT )
		}
		
		if ( classifierMapping.partialToElement == false &&  (classifierMapping.toElement as Class).partial == true) {
			error('Missing | at ' + classifierMapping.toElement.name, TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_TO_ELEMENT )
		}
		
		if ( classifierMapping.partialToElement == true &&  (classifierMapping.toElement as Class).partial == false) {
			error('The class ' + classifierMapping.toElement.name + ' is not a partial class (toElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_TO_ELEMENT )
		}
	}
	
	@Check
	def checkMessageViewBody(TAbstractMessageView messageView) {
		if ( messageView.lifelines.size > 0 && messageView.messages.size == 0 ) {
			error('Message views are mandatory', TextRamPackage.Literals.TABSTRACT_MESSAGE_VIEW__LIFELINES)
		}
	}
	
}