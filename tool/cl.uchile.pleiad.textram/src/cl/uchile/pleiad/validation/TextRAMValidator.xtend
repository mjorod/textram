/*
 * generated by Xtext
 */
package cl.uchile.pleiad.validation

import ca.mcgill.cs.sel.ram.Aspect
import ca.mcgill.cs.sel.ram.Class
import ca.mcgill.cs.sel.ram.RamPackage
import cl.uchile.pleiad.textRam.TAbstractMessageView
import cl.uchile.pleiad.textRam.TAbstractMessages
import cl.uchile.pleiad.textRam.TAssociation
import cl.uchile.pleiad.textRam.TClass
import cl.uchile.pleiad.textRam.TClassifierMapping
import cl.uchile.pleiad.textRam.TInteractionMessage
import cl.uchile.pleiad.textRam.TLifeline
import cl.uchile.pleiad.textRam.TLifelineReferenceType
import cl.uchile.pleiad.textRam.TLocalAttribute
import cl.uchile.pleiad.textRam.TMessage
import cl.uchile.pleiad.textRam.TOperation
import cl.uchile.pleiad.textRam.TParameter
import cl.uchile.pleiad.textRam.TReference
import cl.uchile.pleiad.textRam.TValueSpecification
import cl.uchile.pleiad.textRam.TextRamPackage
import cl.uchile.pleiad.util.TextRamEcoreUtil
import java.util.List
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.validation.Check

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class TextRAMValidator extends AbstractTextRAMValidator {

	@Check
	def checkOperationIsValidOnInteraction(TMessage tMessage){
		val tInteraction = tMessage.eContainer as TInteractionMessage
		
		// check operation signature
		var TClass clazz = null
		val signature = tMessage.signature
		val messageArguments = tMessage.arguments
		
		val List<TOperation> operations = getAllOperationsFromInteractionMesage(tInteraction, signature.name)

		if (operations.empty == true) {
			error('The operation ' + signature.name + ' is undefined for the class ' + clazz.name, TextRamPackage.Literals.TMESSAGE__SIGNATURE)
		}
			
		// there is no operation's overloading
		if ( operations.areOverloaded == false ) {
			val currentOperation = operations.get(0)
			
			if ( haveSameNumberOfArgumentsOnMessageInteraction( currentOperation.parameters, messageArguments ) == false ) {
				error('Invalid number of arguments on ' + signature.name, TextRamPackage.Literals.TMESSAGE__ARGUMENTS)
				return				
			}
			
			if ( haveSameArgumentsTypeOnMessageInteraction( currentOperation.parameters, messageArguments ) == false ) {
				//TODO: which parameter?
				error('Type mismatch: cannot convert from parameters', TextRamPackage.Literals.TMESSAGE__ARGUMENTS)
				return		
			}

		} 
		else {
			// there is operation overloading
			val o = operations.findOperationThatMatchArgumentsSignatureOnMessageInteraction( messageArguments )
			if ( o == null) {
				error('The operation ' + signature.name + ' has invalid arguments ', TextRamPackage.Literals.TMESSAGE__SIGNATURE)
				return
			}
		}		
	}
	
	@Check
	def checkOperationIsValidOnMessageView(TAbstractMessages messageView) {
		
		val clazz = messageView.class_ 
		val messageViewOperation = messageView.specifies
		val messageViewArguments = messageView.arguments

		val Aspect aspect = TextRamEcoreUtil.getRootContainerOfType( messageView, RamPackage.Literals.ASPECT ) 

		val List<TOperation> operations = aspect.getAllOperations(clazz, messageViewOperation.name) 		

		if (operations.empty == true) {
			error('The operation ' + messageViewOperation.name + ' is undefined', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
			return
		}

		if ( operations.haveAmbiguityDefinition == true ) {
				error('ambiguity in operation definition', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
				return
		}
				
		if ( operations.areOverloaded == false ) {
			val currentOperation = operations.get(0)
			
			if ( haveSameNumberOfArguments( currentOperation.parameters, messageViewArguments ) == false ) {
				error('Invalid number of arguments on ' + messageViewOperation.name, TextRamPackage.Literals.TABSTRACT_MESSAGES__ARGUMENTS)
				return				
			}
			
			if ( haveSameArgumentsType( currentOperation.parameters, messageViewArguments ) == false ) {
				//TODO: which parameter?
				error('Type mismatch: cannot convert from parameters', TextRamPackage.Literals.TABSTRACT_MESSAGES__ARGUMENTS)
				return		
			}
		} 
		else {
			// there is operation overloading
			val o = operations.findOperationThatMatchArgumentsSignature( messageViewArguments )
			if ( o == null) {
				error('The operation ' + messageViewOperation.name + ' has invalid arguments ', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
				return
			}
		}
	
	}
	
	private def getAllOperationsFromInteractionMesage(TInteractionMessage tInteraction, String operationName) {
		val List<TOperation> result = newArrayList
		
		var TClass clazz = null
		
		if (tInteraction.rightLifeline.referenceType == TLifelineReferenceType.REFERENCE) {
			clazz = tInteraction.rightLifeline.represents as TClass
		}
		
		if (tInteraction.rightLifeline.referenceType == TLifelineReferenceType.ASSOCIATION) {
			clazz = (tInteraction.rightLifeline.represents as TAssociation).toEnd.classReference as TClass
		}
		
		if (tInteraction.rightLifeline.referenceType == TLifelineReferenceType.ATTRIBUTE) {
			throw new Exception("Attributes not supported as TLifeline references")
		}
		
		result.addAll( TextRamEcoreUtil.findOperations( clazz, operationName) )
		
		result
	}
	
	private def getAllOperations(Aspect aspect, TClass optionalClass, String operationName) {
		val List<TOperation> result = newArrayList
		
		if ( optionalClass.isDefined ) {
			result.addAll( TextRamEcoreUtil.findOperations(optionalClass, operationName) )
		}
		else {
			result.addAll ( TextRamEcoreUtil.findAspectOperations( aspect, operationName ) )
		}
		
		result
	}
	
	private def findOperationThatMatchArgumentsSignatureOnMessageInteraction(List<TOperation> operations, EList<TValueSpecification> arguments) {
		var TOperation result = null
		
		for ( o : operations ) {
			if ( haveSameNumberOfArgumentsOnMessageInteraction( o.parameters, arguments ) == true &&
				 haveSameArgumentsTypeOnMessageInteraction( o.parameters, arguments ) == true ) {
				result = o
			}			
		}
		
		result 
	}
	
	private def findOperationThatMatchArgumentsSignature(List<TOperation> operations, EList<TParameter> arguments) {
		var TOperation result = null
		
		for ( o : operations ) {
			if ( haveSameNumberOfArguments( o.parameters, arguments ) == true &&
				 haveSameArgumentsType( o.parameters, arguments ) == true ) {
				result = o
			}			
		}
		
		result 
	}
	
	private def dispatch getTypeNameForTValueSpecification(TLocalAttribute specification) {
		specification.type.name
	}
	
	private def dispatch getTypeNameForTValueSpecification(TReference specification) {
		(specification.reference as TClass).name
	}
	
	private def dispatch getTypeNameForTValueSpecification(TParameter specification) {
		specification.type.name
	}
	
	private def dispatch getTypeNameForTValueSpecification(TLifeline l) {
		if (l.referenceType != TLifelineReferenceType.REFERENCE) {
			throw new Exception("Only Reference types can be parameters");
		}
		
		(l.represents as TClass).name
	}
	
	private def haveSameArgumentsTypeOnMessageInteraction(EList<TParameter> list, EList<TValueSpecification> list2) {
		// assumes both lists have the same size
		if (list.size != list2.size) {
			throw new Exception("Argument's lists are not the same size")
		}
		
		if ( list.empty == false && list2.empty == false ) {
			for ( Integer i: 0..list.size - 1) {
				if ( list.get(i).type.name != list2.get(i).typeNameForTValueSpecification) {
					return false;
				}
			}
		}
				
		return true;
	}
	
	private def haveSameArgumentsType(EList<TParameter> list, EList<TParameter> list2) {
		// assumes both lists have the same size
		if (list.size != list2.size) {
			throw new Exception("Argument's lists are not the same size")
		}
		
		if ( list.empty == false && list2.empty == false ) {
			for ( Integer i: 0..list.size - 1) {
				if ( list.get(i).type.name != list2.get(i).type.name ) {
					return false;
				}
			}
		}
		
		return true;
	}
	
	private def haveSameNumberOfArguments(EList<TParameter> list, EList<TParameter> list2) {
		return list.size == list2.size
	}
	
	private def haveSameNumberOfArgumentsOnMessageInteraction(EList<TParameter> list, EList<TValueSpecification> list2) {
		return list.size == list2.size
	} 
	
	private def areOverloaded(List<TOperation> operations) {
		return operations.size > 0
	}
	
	private def haveAmbiguityDefinition(List<TOperation> operations) {
		return operations.size > 1
	}
	
	private def isDefined(TClass clazz) {
		return clazz != null;
	}
	
	@Check
	def checkPartialDefinitionForTOperationReturnType(TOperation operation){
		if (operation.returnType instanceof TClass) {
			val returnType = operation.returnType as TClass
			if (returnType.partial == true && operation.partialReturnType == false) {
				error('Missing | at ' + operation.name, TextRamPackage.Literals.TOPERATION__RETURN_TYPE)
			}
			
			if (returnType.partial == false && operation.partialReturnType == true) {
				error('Missing | at '+ operation.name, TextRamPackage.Literals.TOPERATION__RETURN_TYPE)
			}
		}
	}
	
	@Check
	def checkPartialDefinitionForTParameterType(TParameter parameter) {
		if (parameter.type instanceof TClass) {
			val returnType = parameter.type as TClass
			if (returnType.partial == true && parameter.partialType == false) {
				error('Missing | at ' + parameter.name, TextRamPackage.Literals.TPARAMETER__TYPE)
			}
			
			if (returnType.partial == false && parameter.partialType == true) {
				error('Missing | at ' + parameter.name, TextRamPackage.Literals.TPARAMETER__TYPE)
			}
		}
	}
	
	@Check
	def checkPartialDefinitionsOnTAbstractMessages(TAbstractMessages messageView) {
		val clazz = messageView.class_
		val operation = messageView.specifies
		
		if (clazz != null && clazz.partial != messageView.partialClass) {
			if (clazz.partial == true) {
				error('The class ' + clazz.name +' has to be defined as partial.', TextRamPackage.Literals.TABSTRACT_MESSAGES__CLASS)
			}
			else {
				error('The class ' + clazz.name + ' is not a partial class.' , TextRamPackage.Literals.TABSTRACT_MESSAGES__CLASS)
			}
		}
		
		if (operation != null && operation.partial != messageView.partialOperation) {
			if (operation.partial == true) {
				error('The operation ' + operation.name +' has to be defined as partial.', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
			}
			else {
				error('The operation ' + operation.name + ' is not a partial operation.' , TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
			}
		}		
	}
	
	@Check
	def checkPartialDefinitionOnReference(TReference reference) {
		if (reference.partialClass == false && reference.reference.partial == true) {
			error('The class ' + reference.reference.name + ' has to be defined as partial.', TextRamPackage.Literals.TREFERENCE__REFERENCE )
		}
		
		if (reference.partialClass == true && reference.reference.partial == false ) {
			error('The class ' + reference.reference.name + ' is not a partial class.', TextRamPackage.Literals.TREFERENCE__REFERENCE ) 
		}
	}
	
	@Check
	def checkPartialDefinitionOnTMessageWithSignature(TMessage message) {
		if (message.partialOperation == false && message.signature.partial == true) {
			error('The class ' + message.signature.name + ' has to be defined as partial.', TextRamPackage.Literals.TMESSAGE__SIGNATURE )
		}
		
		if (message.partialOperation == true && message.signature.partial == false) {
			error('The class ' + message.signature.name + ' is not a partial class.', TextRamPackage.Literals.TMESSAGE__SIGNATURE) 
		}
	}
	
	@Check
	def checkPartialDefinitionOnTClassifierMapping(TClassifierMapping classifierMapping) {
		if ( classifierMapping.partialFromElement == false &&  (classifierMapping.fromElement as Class).partial == true) {
			error('The class ' + classifierMapping.fromElement.name + ' has to be defined as partial (fromElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_FROM_ELEMENT )
		}
		
		if ( classifierMapping.partialFromElement == true &&  (classifierMapping.fromElement as Class).partial == false) {
			error('The class ' + classifierMapping.fromElement.name + ' is not a partial class (fromElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_FROM_ELEMENT )
		}
		
		if ( classifierMapping.partialToElement == false &&  (classifierMapping.toElement as Class).partial == true) {
			error('The class ' + classifierMapping.toElement.name + ' has to be defined as partial (toElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_TO_ELEMENT )
		}
		
		if ( classifierMapping.partialToElement == true &&  (classifierMapping.toElement as Class).partial == false) {
			error('The class ' + classifierMapping.toElement.name + ' is not a partial class (toElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_TO_ELEMENT )
		}
	}
	
	@Check
	def checkMessageViewBody(TAbstractMessageView messageView) {
		if ( messageView.lifelines.size > 0 && messageView.messages.size == 0 ) {
			error('Message views are mandatory', TextRamPackage.Literals.TABSTRACT_MESSAGE_VIEW__LIFELINES)
		}
	}
}