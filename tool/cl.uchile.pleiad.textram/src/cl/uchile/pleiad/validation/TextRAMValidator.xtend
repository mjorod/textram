/*
 * generated by Xtext
 */
package cl.uchile.pleiad.validation

import ca.mcgill.cs.sel.ram.Aspect
import ca.mcgill.cs.sel.ram.Class
import ca.mcgill.cs.sel.ram.Parameter
import ca.mcgill.cs.sel.ram.RamPackage
import cl.uchile.pleiad.textRam.TAbstractMessageView
import cl.uchile.pleiad.textRam.TAbstractMessages
import cl.uchile.pleiad.textRam.TClass
import cl.uchile.pleiad.textRam.TClassifierMapping
import cl.uchile.pleiad.textRam.TMessage
import cl.uchile.pleiad.textRam.TOperation
import cl.uchile.pleiad.textRam.TReference
import cl.uchile.pleiad.textRam.TextRamPackage
import cl.uchile.pleiad.util.TextRamEcoreUtil
import java.util.List
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.validation.Check

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class TextRAMValidator extends AbstractTextRAMValidator {

//	@Check
//	def checkOperationIsValidOnInteraction(TMessage tMessage){
//		val tInteraction = tMessage.eContainer as TInteractionMessage
//		
//		// check operation signature
//		var TClass clazz = null
//		val operation = tMessage.signature
//		val arguments = tMessage.arguments
//		
//		val List<TOperation> operations = newArrayList
//		
//		if (tInteraction.rightLifeline.referenceType == TLifelineReferenceType.REFERENCE) {
//			clazz = tInteraction.rightLifeline.represents as TClass
//		}
//		
//		if (tInteraction.rightLifeline.referenceType == TLifelineReferenceType.ASSOCIATION) {
//			clazz = (tInteraction.rightLifeline.represents as TAssociation).toEnd.classReference as TClass
//		}
//		
//		if (tInteraction.rightLifeline.referenceType == TLifelineReferenceType.ASSOCIATION) {
//			throw new Exception("Attributes not supported as TLifeline references")
//		}
//		
//		operations.addAll( TextRamEcoreUtil.findOperations( clazz, operation.name) )
//			
//		// error if the operation doesn't exists
//		if (operations.length == 0) {
//			error('The operation ' + operation.name + ' is undefined for the class ' + clazz.name, TextRamPackage.Literals.TMESSAGE__ARGUMENTS)
//		}
//			
//		// there is no operation's overloading
//		if ( operations.length == 1 ) {
//			if (operations.get(0).parameters.length != arguments.length ) {
//				error('Invalid number of arguments on ' + operation.name, TextRamPackage.Literals.TMESSAGE__ARGUMENTS)
//			}
//		
//			// check arguments's type
//			if (operations.get(0).parameters.length > 0) { 
//				for ( Integer i: 0..operations.get(0).parameters.size - 1) {
//					if ( arguments.get(i).typeNameForTValueSpecification != operations.get(0).parameters.get(i).type.name ) {
//						error('Type mismatch: cannot convert from  ' + arguments.get(i).typeNameForTValueSpecification + ' to ' + operations.get(0).parameters.get(i).type.name, TextRamPackage.Literals.TABSTRACT_MESSAGES__ARGUMENTS)
//					}
//				}
//			}
//		}
//		
//		// there is operation's overloading
//		if ( operations.length > 1 ) {
//			var matchSignature = false
//			
//			// check the operation's signature
//			for ( o : operations ) {
//
//				if (matchSignature == false) {
//					// check operation's length
//					if ( o.parameters.length == arguments.length ) {
//						
//						var matchParametersType = true
//						for ( Integer i: 0..o.parameters.size - 1) {
//							if ( o.parameters.get(i).type.name != arguments.get(i).typeNameForTValueSpecification ) {
//								matchParametersType = false
//							}
//						}
//						
//						if (matchParametersType == true) {
//							matchSignature = true
//						}
//					}
//				}
//			}
//			
//			if (matchSignature == false) {
//				error('The operation ' + operation.name + ' has invalid arguments ', TextRamPackage.Literals.TMESSAGE__ARGUMENTS)
//			}		
//		
//		}
//	}
//	
//	private def dispatch getTypeNameForTValueSpecification(TLocalAttribute specification) {
//		specification.type.name
//	}
//	
//	private def dispatch getTypeNameForTValueSpecification(TReference specification) {
//		(specification.reference as TClass).name
//	}
//	
//	private def dispatch getTypeNameForTValueSpecification(TParameterValue specification) {
//		specification.name
//	}
	
//	private def dispatch getTypeNameForTValueSpecification(TLifeline l) {
//		if (l.referenceType != TLifelineReferenceType.REFERENCE) {
//			throw new Exception("Only Reference types can be parameters");
//		}
//		
//		(l.represents as TClass).name
//	}

//	@Check
//	def checkOperationIsValidOnMessageView(TAbstractMessages messageView) {
//		
//		val clazz = messageView.class_ 
//		val messageViewOperation = messageView.specifies
//		val messageViewArguments = messageView.arguments
//
//		val Aspect aspect = TextRamEcoreUtil.getRootContainerOfType( messageView, RamPackage.Literals.ASPECT ) 
//
//		val List<TOperation> operations = aspect.getAllOperations(clazz, messageViewOperation.name) 		
//
//		if (operations.empty == true) {
//			error('The operation ' + messageViewOperation.name + ' is undefined', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
//			return
//		}
//
//		if ( operations.haveAmbiguityDefinition == true ) {
//				error('ambiguity in operation definition', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
//				return
//		}
//				
//		if ( operations.areOverloaded == false ) {
//			val currentOperation = operations.get(0)
//			
//			if ( haveSameNumberOfArguments( currentOperation.parameters, messageViewArguments ) == false ) {
//				error('Invalid number of arguments on ' + messageViewOperation.name, TextRamPackage.Literals.TABSTRACT_MESSAGES__ARGUMENTS)
//				return				
//			}
//			
//			if ( haveSameArgumentsType( currentOperation.parameters, messageViewArguments ) == false ) {
//				//TODO: which parameter?
//				error('Type mismatch: cannot convert from parameters', TextRamPackage.Literals.TABSTRACT_MESSAGES__ARGUMENTS)
//				return		
//			}
//		} 
//		else {
//			// there is operation overloading
//			val o = operations.findOperationThatMatchArgumentsSignature( messageViewArguments )
//			if ( o == null) {
//				error('The operation ' + messageViewOperation.name + ' has invalid arguments ', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
//				return
//			}
//		}
//	
//	}
	
	def getAllOperations(Aspect aspect, TClass optionalClass, String operationName) {
		val List<TOperation> result = newArrayList
		
		if ( optionalClass.isDefined ) {
			result.addAll( TextRamEcoreUtil.findOperations(optionalClass, operationName) )
		}
		else {
			result.addAll ( TextRamEcoreUtil.findAspectOperations( aspect, operationName ) )
		}
		
		result
	}
	
	def findOperationThatMatchArgumentsSignature(List<TOperation> operations, EList<Parameter> arguments) {
		var TOperation result = null
		
		for ( o : operations ) {
			if ( haveSameNumberOfArguments( o.parameters, arguments ) == true &&
				 haveSameArgumentsType( o.parameters, arguments ) == true ) {
				result = o
			}			
		}
		
		result 
	}
	
	def haveSameArgumentsType(EList<Parameter> list, EList<Parameter> list2) {
		// assumes both lists have the same size
		if (list.size != list2.size) {
			throw new Exception("Argument's lists are not the same size")
		}
		
		if ( list.empty == false && list2.empty == false ) {
			for ( Integer i: 0..list.size - 1) {
				if ( list.get(i).type.name != list2.get(i).type.name ) {
					return false;
				}
			}
		}
		
		return true;
	}
	
	def haveSameNumberOfArguments(EList<Parameter> list, EList<Parameter> list2) {
		return list.size == list2.size
	}
	
	def areOverloaded(List<TOperation> operations) {
		return operations.size > 0
	}
	
	def haveAmbiguityDefinition(List<TOperation> operations) {
		return operations.size > 1
	}
	
	def isDefined(TClass clazz) {
		return clazz != null;
	}
	
	@Check
	def checkPartialDefinitionsOnTAbstractMessages(TAbstractMessages messageView) {
		val clazz = messageView.class_
		val operation = messageView.specifies
		
		if (clazz != null && clazz.partial != messageView.partialClass) {
			if (clazz.partial == true) {
				error('The class ' + clazz.name +' has to be defined as partial.', TextRamPackage.Literals.TABSTRACT_MESSAGES__CLASS)
			}
			else {
				error('The class ' + clazz.name + ' is not a partial class.' , TextRamPackage.Literals.TABSTRACT_MESSAGES__CLASS)
			}
		}
		
		if (operation != null && operation.partial != messageView.partialOperation) {
			if (operation.partial == true) {
				error('The operation ' + operation.name +' has to be defined as partial.', TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
			}
			else {
				error('The operation ' + operation.name + ' is not a partial operation.' , TextRamPackage.Literals.TABSTRACT_MESSAGES__SPECIFIES)
			}
		}		
	}
	
	@Check
	def checkPartialDefinitionOnReference(TReference reference) {
		if (reference.partialClass == false && reference.reference.partial == true) {
			error('The class ' + reference.reference.name + ' has to be defined as partial.', TextRamPackage.Literals.TREFERENCE__REFERENCE )
		}
		
		if (reference.partialClass == true && reference.reference.partial == false ) {
			error('The class ' + reference.reference.name + ' is not a partial class.', TextRamPackage.Literals.TREFERENCE__REFERENCE ) 
		}
	}
	
	@Check
	def checkPartialDefinitionOnTMessageWithSignature(TMessage message) {
		if (message.partialOperation == false && message.signature.partial == true) {
			error('The class ' + message.signature.name + ' has to be defined as partial.', TextRamPackage.Literals.TMESSAGE__SIGNATURE )
		}
		
		if (message.partialOperation == true && message.signature.partial == false) {
			error('The class ' + message.signature.name + ' is not a partial class.', TextRamPackage.Literals.TMESSAGE__SIGNATURE) 
		}
	}
	
	@Check
	def checkPartialDefinitionOnTClassifierMapping(TClassifierMapping classifierMapping) {
		if ( classifierMapping.partialFromElement == false &&  (classifierMapping.fromElement as Class).partial == true) {
			error('The class ' + classifierMapping.fromElement.name + ' has to be defined as partial (fromElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_FROM_ELEMENT )
		}
		
		if ( classifierMapping.partialFromElement == true &&  (classifierMapping.fromElement as Class).partial == false) {
			error('The class ' + classifierMapping.fromElement.name + ' is not a partial class (fromElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_FROM_ELEMENT )
		}
		
		if ( classifierMapping.partialToElement == false &&  (classifierMapping.toElement as Class).partial == true) {
			error('The class ' + classifierMapping.toElement.name + ' has to be defined as partial (toElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_TO_ELEMENT )
		}
		
		if ( classifierMapping.partialToElement == true &&  (classifierMapping.toElement as Class).partial == false) {
			error('The class ' + classifierMapping.toElement.name + ' is not a partial class (toElement).', TextRamPackage.Literals.TCLASSIFIER_MAPPING__PARTIAL_TO_ELEMENT )
		}
	}
	
	@Check
	def checkMessageViewBody(TAbstractMessageView messageView) {
		if ( messageView.lifelines.size > 0 && messageView.messages.size == 0 ) {
			error('Message views are mandatory', TextRamPackage.Literals.TABSTRACT_MESSAGE_VIEW__LIFELINES)
		}
	}
}