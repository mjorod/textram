\documentclass[a4paper,10pt]{scrartcl}
\usepackage[utf8x]{inputenc}

\usepackage[left=1.25in,top=1.3in,right=1.25in,bottom=1.25in,nohead,nofoot]{geometry}

\usepackage{epsfig}

\usepackage{setspace}

\title{\LARGE{Extending AspectOPTIMA to support\\Open Multithreaded Transactions} \large{\ \\ \ \\ Undergraduate Research Project COMP 396}}

\renewcommand{\baselinestretch}{1.25}
\setlength{\footskip}{10ex}

\author{Max Kramer} 
%\date{30. Juli 2010} 

\makeatletter
\renewcommand{\@maketitle}{
\newpage
 \vspace*{\fill}
 \begin{center}%
  {\Large \@title \\ \ \\ \@author \\ \ \\ April 20, 2010 \\ \ \\ McGill University, Montr\'eal, Queb\'ec, Canada \\ \ \\ Supervisor: J\"org Kienzle \\ Instructor: Nathan Friedman \\ \ \\ \ \\ \ \\}%
 \end{center}%
 \par
 \vspace*{\fill}} \makeatother

\begin{document}

\maketitle

\newpage

\setcounter{tocdepth}{3} 

\renewcommand{\contentsname}{Table of Contents}

\tableofcontents

\newpage

\section{Introduction}

This report describes the results of an Undergraduate Research Project (COMP 396) at McGill University that addressed the modeling of a framework for advanced transactions called ``Open Multithreaded Transactions'' (OMTT) using the aspect-oriented modeling technique ``Reusable Aspect Models'' (RAM). The project is based on previous work of other students and researchers at McGill University that led to the development of RAM and to the modeling of the transaction framework ``AspectOPTIMA''. The remainder of this report is structured as follows: In chapter 2 we provide background information on aspect-oriented modeling in general and Reusable Aspect Models in special, as well as a general description of Open Multithreaded Transactions. The main part of this report is the detailed description of the results of our modeling effort in chapter 3. In order to put our work into a broader context we present related work in chapter 4 and discuss future work and conclusions in chapter 5.

\section{Background}

\subsection{Aspect-Oriented Modeling}

Aspect-Orientation is a development paradigm that addresses crosscutting concerns and that can be applied at any phase during the software development process. Aspect-oriented modeling allows a system modeler to identify, represent, separate and compose crosscutting properties while designing or analyzing a software system. 

\subsubsection{Overview}

During the last decade aspect-oriented programming \cite{AOP} techniques have matured to powerful and sophisticated tools that allow developers to express crosscutting concerns of large and complex systems separately \cite{AspectJ_in_Action}. Understanding the technical details of these mechanisms can be hard and developers often need to separate the structure and logic of the analyzed concerns mentally from the syntax and structure of the code. This process can be error-prone and introduce accidental complexity, thus leading to a shift of complexity instead of reducing it.

The development of aspect-oriented modeling (AOM) approaches gives a modeler the possibility to reason about crosscutting concerns individually on a higher level of abstraction without regards to the technical details of their implementation \cite{11thAOM}. By using existing visual descriptions AOM provides the means to transform crosscutting concerns into interacting concerns and to focus on their semantics, composition and conflicts. One field of research in AOM tries to find appropriate modeling abstractions that express these concerns, their interaction amongst each other and their relationship to non-crosscutting concerns. For this purpose either existing modeling notations are extended with constructs similar to those of aspect-oriented languages such as pointcuts and advice \cite{ThemeUML} or completely new modeling notations are created.
Other research work in the AOM community is concerned with model transformation and composition in order to develop model weavers that resolve and flatten aspect-oriented models to conventional models. Such model-weaving techniques enable consistency checks, ease the modeling by providing a view of the resulting system and provide the freedom of targeting platforms without support for aspect-oriented language constructs.
Aspect-oriented modeling approaches cover the whole software development cycle and span from requirements elicitation (e.g AoURN \cite{AoURN}) to detailed design models (e.g. Reusable Model Slices \cite{Reusable_Model_Slices}).

\subsubsection{Reusable Aspect Models}

Reusable Aspect Models \cite{Reusable_Aspect_Models} is an aspect-oriented modeling approach that supports detailed design using three modeling notations \cite{AOMVM}. This multi-view modeling makes it possible to represent different subconcerns with the most appropriate modeling notation and leads to a higher expressivity than single-view approaches. Each stand-alone aspect is represented by a UML class diagram for structural modeling, optional state views that define the invocation protocol as UML state diagrams and message views (UML sequence diagrams) for at least each public method. Every of these UML views has additional aspect-oriented features that are not part of UML, such as parameters, pointcuts and advice. RAM also addresses inter-aspect relations by supporting the definition of dependency chains that facilitate reuse. 

The model weaver provided by RAM has composing capabilities for every diagram type and offers additional consistency checks. Dependencies are automatically resolved and for each sequence diagram the corresponding state views are taken into account in order to verify that no message violates the invocation protocol. Even if this adds additional complexity to the weaving process it reduces the likelihood of failure as the use of a method that is not defined in the structural view or forbidden at this state of computation in the state view is already detected during the modeling process.

The syntactical details of RAM are beyond the scope of this report but we want to make the reader familiar with the main concepts of Reusable Aspect Models:
The structural view can contain complete classes and incomplete classes that need to be be instantiated prior to use. These ``mandatory instantiation parameters'' are marked by prepending $|$ to their name. Existing classes and states can be bound with a binding directive similar to instantiation directives by writing ``NameToBind $\rightarrow$ BoundName''. State and message views use a common pointcut-advice notation in order to define patterns of states or messages that should be replaced with the defined advice. An in-depth discussion of the features of Reusable Aspect Models can be found in \cite{AOMVM}.

\subsection{Open Multithreaded Transactions}

Open Multithreaded Transactions \cite{OMTTKTEUC} is a transaction model that addresses concurrency problems of conservative transactional systems by providing features for controlled cooperation between threads.

\subsubsection{Motivation}
Sequential transaction models impede concurrency features of modern systems by restricting transactions to single threads in order to achieve isolation.  Cooperation between threads is not foreseen and unregulated concurrency in transactional systems that were not designed to support concurrency leads to inconsistent states. Transactional models that enable concurrency while still guaranteeing the ACID \cite{ACID} properties are of great benefit to distributed systems and modern multi-core platforms. Open Multithreaded Transaction were designed to address these problems by providing enough control for ensuring transactional properties and as much freedom as possible in order to support cooperation between threads.

\subsubsection{Features}

\begin{figure}[t!]
 \centering
 \includegraphics[width=\textwidth]{pdfs/an_omtt}
 \caption{An Example of two Open Multithreaded Transaction from \cite{OMTT}}
 \label{an_omtt}
\end{figure}

\textit{\hspace{2.3ex}Opening~} If an arbitrary thread starts a transaction it will be the first joined participant of this open transaction.

\textit{Nesting~} If a participant starts a new transaction this transaction will be nested as a child of the previous transaction of this participant. (Sibling transactions that were created by different participants execute concurrently.)

\textit{Joining~} In order to join a transaction a thread must either participate in a parental transaction or not participate in any transaction at all and the transaction to be joined must be open. (A thread can only participate in one sibling transaction at a time.)

\textit{Spawning~} Participants of transactions can spawn new participants that will automatically become spawned participants of the innermost transaction of their creator.

\textit{Closing~} Every participant of a transaction can close it at any time such that no new threads can join the transaction anymore. (New threads can still be spawned inside the transaction and every transaction closes automatically once all participants voted on an outcome.)

\textit{Isolation~} Participants access transactional objects in complete isolation from other transactions even if these transactions are nested children of their current transaction.

% TODO access to parental transactional objects???

\textit{Voting~} Participants can vote on the outcome of the transaction that they are participating in and threads that ``disappear'' without voting implicitly voted \textit{abort}.

\textit{Commiting~} A transaction reveals the changes to its transactional objects to the outside world if and only if all participants voted \textit{commit}.

\textit{Terminating~} Spawned participants terminate immediately after voting on the outcome of a transaction.

\textit{Leaving~} Joined participants cannot leave a transaction before its outcome has been decided and are therefore blocked until the last participant voted \textit{commit} or a participant voted \textit{abort}.

Figure \ref{an_omtt} shows an example of two nested Open Multithreaded Transactions with four joined participants A, B. C and D and two spawned participants B' and C' that demonstrates the blocking behaviour.

% \subsubsection{Exceptions}

\subsection{AspectOPTIMA}

\begin{figure}[t!]
 \centering
 \includegraphics[width=\textwidth]{pdfs/AspectOPTIMA_feature_diagram}
 \caption{The feature diagram for the original AspectOPTIMA transaction framework}
 \label{aspect_optima_feature_diagram}
\end{figure}

AspectOPTIMA \cite{AspectOPTIMA} is a transaction framework that has been modeled using Reusable Aspect Models. The main goal during the development of AspectOPTIMA was to create a case study that can be used to examine aspect-oriented modeling and implementation techniques. As inter-aspect relations, dependencies and conflicts are important concerns in aspect-oriented systems the case study models different concurrency and recovery mechanism in order to provide support for different configurations. Figure \ref{aspect_optima_feature_diagram} presents the feature diagram of the original AspectOPTIMA transaction framework with its aspects, conflict resoultions, composition rules and variation points.

\section{Open Multithreaded Transactions for AspectOPTIMA}

\subsection{Overview}

We modeled Open Multithreaded Transactions using the Reusable Aspect Models approach as an extension to the existing RAM model of the transaction system AspectOPTIMA. The decomposition of the different features of OMTT resulted in the design of eleven aspects that reuse each other and demanded the definition of three conflict resolutions. By depending directly on the four aspects \textit{OutcomeAware}, \textit{Nested}, \textit{Context} and \textit{Transaction} of the AspectOPTIMA model we where able to reuse their functionality seamlessly and to focus on the advanced features of Open Multithreaded Transactions.

In figure \ref{OMTT_feature_diagram} we present the feature diagram for our model and show which combinations of aspects were resolved with conflict resolutions. The fact that almost every new aspect depends directly or indirectly on \textit{Collaborative} illustrates that the main principle of OMTT is collaboration. The only exception to this dependency are \textit{Pausable}, \textit{Terminatable}, \textit{OutcomeVotable} and \textit{OutcomeVoting}. These aspects build a dependency chain that shows that determining the outcome is essential for ensuring the ACID properties of a OMTT and that RAM's inter-aspect mechanisms allow fine-grained separation in order to facilitate reuse.

The Open Multithreaded Transaction aspect is the heart of our extension and depends directly or indirectly on every other aspect of the framework extension. Note that these dependencies are not a smell for bad design as in some other software systems but a proof of the fact that our model contains no unused or superfluous functionality.

\begin{figure}
 \centering
 \includegraphics[scale=0.75]{pdfs/feature_diagram}
 \caption{The feature diagram for the OMTT extension to AspectOPTIMA}
 \label{feature_diagram}
\end{figure}

% TODO mention special role of OMTT aspect

% TODO dependency diagram
% Collaborative <- ExitSync
% 		<- EntrySync 
% 		<- SpawnSupporting
% Context <- Collaborative <- Closable
%         <- Pausable <- Terminatable <- OutcomeVotable
% OutcomeAware <- OutcomeVotable <- OutcomeVoting
% Shared <- Collaborative

\subsection{Aspects}

Our Open Multithreaded Transaction model contains eleven aspects that package the main functionality and structure in small units that can be reused in other environments and frameworks.

\subsubsection{Context}

As an introduction into AspectOPTIMA and RAM we present the \textit{Context} aspect of the original AspectOPTIMA framework for common transactions. \textit{Context} is a central unit of AspectOPTIMA that allows active threads to take part in transactions by creating transaction contexts and becoming their \textit{Participant}. The fact that the structural view defines that every \textit{Participant} is related to at most one \textit{Context} and that every \textit{Context} has at most one \textit{Participant} shows us that AspectOPTIMA strictly isolates transactions. The invocation protocol defined by the state view of \textit{Context} ensures this isolation and the corresponding cardinalities by only allowing the invocation of the method \textit{addParticipant} if no participant has been added so far or if a single participant has been added but already been removed by \textit{removeParticipant}. A similar constraint is enforced by the state view of \textit{Participant}: the introduction of intermediate states \textit{Entering} and \textit{Leaving} and the two edges for \textit{setContext} ensure that the context of a participant will only be set from within the methods \textit{createAndEnterContext} and \textit{leaveContext}. In the message view of these two methods and the remaining public method \textit{enterContext} their detailed behavior and the modification of the relation between \textit{Context} and \textit{Participant} is illustrated.

\begin{figure}
 \centering
 \includegraphics[height=\textheight]{pdfs/Context}
 \caption{The Context aspect}
\end{figure}

\subsubsection{Collaborative}

% DONE !! remove contextCompleted from Collaborative.leaveContext
% DONE remove Shared from Collaborative as it is never used

The \textit{Collaborative} aspect provides core functionalities to all other aspects as collaboration is the main principle of Open Multithreaded Transactions. It modifies the cardinality constraints mentioned above and provides facilities for joining already existing contexts by adding the methods \textit{joinContext} and \textit{isAllowedToJoin}. The state view for \textit{Context} ensures the modified cardinality by allowing the invocation of \textit{addParticipant} in state \textit{Active} and restricting the number of invocations of \textit{removeParticipant} to the number of \textit{Participants}. The refinement of the state view of \textit{Participant} integrates the new methods into the invocation protocol and shows that a participant that entered a context after joining it exhibits the same behavior as a participant that created and joined the context. The message view of \textit{joinContext} demonstrates the use of the result of a call to \textit{isAllowedToJoin} as a condition for entering the context. We can consider the message view of \textit{isAllowedToJoin} as a ``default implementation'' that can be ``overridden'' conveniently if another behavior is desired. In the standard case a participant can only join a context if it is not already participating in a context. The message view for \textit{leaveContext} is identical to \textit{Context.leaveContext} except for the omitted call to \textit{contextCompleted}.

\begin{figure}
 \centering
 \includegraphics[width=\textwidth]{pdfs/Collaborative}
 \caption{The Collaborative aspect}
\end{figure}

\subsubsection{Closable}

% TODO remove context participant relation everywhere where it does not change

The \textit{Closable} aspect extends \textit{Collaborative} and adds the possibility to close a context in order to prevent participants from joining it. Furthermore the notion of an upper bound of participants is introduced that closes the context automatically once this bound is reached. The only differences in the structural view compared to \textit{Collaborative} are the new methods \textit{isClosed}, \textit{close}, \textit{setMaxParticipantCount} and \textit{getMaxParticipantCount}. In the state view of \textit{ClosableContext} we define that participants can only be added if the context is not closed and that a context can only be closed once. The first restriction is ensured in the message view of \textit{joinContext} by skipping its original internal logic in the case of a closed context. The message view of \textit{addParticipant} shows that we check the number of current participants every time after we added a participant to a context and automatically close it once the number of participants reached the allowed maximum.  

\begin{figure}[th!]
 \centering
 \includegraphics[width=\textwidth]{pdfs/Closable}
 \caption{The Closable aspect}
\end{figure}

\subsubsection{ExitSynchronizing}

% DONE shrink the pointcut and advice in ExitSynchronizingParticipant

\textit{ExitSynchronizing} adds the possibility to synchronize the exit of a \textit{Collaborative} context by blocking all participants that try to exit the context until the last participants tries to exit it. For this purpose we add the methods \textit{getNoOfBlockedParticipants}, \textit{increaseNoOfBlockedParticipants}, \textit{decreaseNoOfBlockedParticipants} and \textit{lastParticipantTriedToLeave} to \textit{ExitSynchronizingContext}'s state view. Moreover we introduce the methods \textit{releaseParticipant}, \textit{blockParticipant} and \textit{unblockParticipant} to \textit{ExitSynchronizingParticipant}.
In its state view the intermediate states \textit{Blocked} and \textit{Releasing} illustrate that every participant will be blocked and eventually be released before it finishes leaving a context by updating its context relation.
The message view for \textit{leaveContext} shows that we replace its original behavior, call \textit{blockParticipant} and keep track of the number of participants that already tried to leave the context and are therefore blocked. Once this number of blocked participants is equal to the number of participants we know that the corresponding participant is the last participant and therefore call \textit{lastParticipantTriedToLeave}. The message view for this method shows that the reaction to this event is the release of every participant. The view for the used method \textit{releaseParticipant} contains the original behavior of \textit{leaveContext} as it removes the participant and updates its context relation but it also makes sure to unblock the participant and to decrease the number of blocked participants accordingly.   

% DONE rename lastParticipantLeft to lastParticipantTriedToLeave or lastParticipantBlocked or lastParticipantIsLeaving

% TODO remove star box for conventional before and after advice

\begin{figure}[th!]
 \centering
 \includegraphics[width=\textwidth]{pdfs/ExitSynchronizing}
 \caption{The ExitSynchronizing aspect}
\end{figure}

\subsubsection{EntrySynchronizing}

The aspect \textit{EntrySynchronizing} adds functionality to \textit{Collaborative} that is similar to \textit{ExitSynchronizing} but allows the synchronization upon entering a context by making all participants wait until a given number of minimal participants is reached. The methods \textit{getNoOfWaitingParticipants}, \textit{increaseNoOfWaitingParticipants}, \textit{decreaseNoOfWaitingParticipants} and \textit{lastParticipantEntered} that are introduced in the structural view to \textit{EntrySynchronizingContext} are completely analogous to the methods of \textit{ExitSynchronizingContext}. As we need a minimal number of participants that are required to start a transaction we also introduce the methods \textit{setMinParticipantCount} and \textit{getMinParticipantCount}. At the participant side we introduce the methods \textit{startParticipant}, \textit{isWaiting}, \textit{setToWaiting} and \textit{setToNotWaiting}.
The state view for \textit{EntrySynchronizingParticipant} shows that every participant will wait after it entered a context and either eventually be set to \textit{notwaiting} and work before it leaves or leave the context directly after waiting. The detailed entering behavior is shown in the message view for \textit{enterContext}: after marking the participant as waiting we check whether the proceeding enter logic was successful and the participant is in fact associated to the desired context. If this is the case we increase the number of waiting participants, retrieve it and compare it to the minimal number of participants in order to call \textit{lastParticipantEntered} if they are equal. The message view of this method is shows that we iterate over all participants in order to mark them as not waiting, start them and decrease the number of waiting participants. In order to start every future participant directly we set the minimal number of required participants to one. To account for the possibility that a participant might leave a context before it finished waiting we add a check to \textit{leaveContext}'s message view and decrease the number of waiting participant in such a case.

% DONE introduce starting to EntrySynchronizingParticipant's state view??

% DONE introduce lastParticipantEntered !!!

% DONE change order: increase, waiting := , min :=

% NOTTODO include setToNotWaiting and decreaseNoOfWaitingParticipants into startParticipant in separate view

% DONE remove star from conventional after (2x)

% DONE remove setToNotWaiting from leaveContext

\begin{figure}
 \centering
 \includegraphics[width=\textwidth]{pdfs/EntrySynchronizing}
 \caption{The EntrySynchronizing aspect}
\end{figure}

\subsubsection{Pausable}

% DONE move addParticipant to top

% DONE change addParticipant advice label and transform to standard before

\textit{Pausable} augments the \textit{Context} aspect with possibilities to pause and continue contexts and their participants arbitrarily. The structural view defines the methods \textit{pauseContext}, \textit{continueContext}, \textit{isPaused}, \textit{setToPaused} and \textit{setToUnpaused} for a \textit{PausableContext} and it also adds \textit{pauseParticipant} and \textit{continueParticipant} methods to its \textit{PausableParticipants}. The state view for \textit{PausableContext} illustrates that the pausing functionality is orthogonal to the other states of a context whereas the state view for \textit{PausableParticipant} shows that only working participants can be paused and continued afterwards. We can infer that this design is sound by examining \textit{pauseContext}'s message view: when a context gets paused we simply mark it as paused and pause all of its participants. These participants can only be working as they are associated with the context. The message view for \textit{continueContext} is completely analogous as we remove the marker and continue all participants. The existing method \textit{addParticipant} gets augmented in a message view in order to make sure that every participant that gets added to a paused context is paused itself prior to adding.

\begin{figure}
 \centering
 \includegraphics[width=\textwidth]{pdfs/Pausable}
 \caption{The Pausable aspect}
\end{figure}

\subsubsection{Terminatable}

% DONE move pause and continue Context up
% DONE inverse leave, pause and terminate participant in struct view

The \textit{Terminatable} aspect makes us of \textit{Pausable} in order to provide the functionality to force the termination of a  context and all its participants. For this purpose we declare the methods \textit{terminateContext} and \textit{contextTerminated} for \textit{TerminatableContext} and \textit{terminateParticipant} for \textit{TerminatableParticipant} as shown in the structural view. \textit{TerminatableContext}'s state view depicts that both idle and active contexts can be terminated but a terminated context cannot be paused or continued. As we pause terminated participants before making them leave the context we need to add the corresponding transition in \textit{TerminatableParticipant}'s state view. The message view for \textit{terminateContext} illustrates that we terminate all its participants before we consider a context terminated and call \textit{contextTerminated}. The method  \textit{terminateParticipant} simply pauses the participant and makes it leave its context as depicted in the corresponding message view.

\begin{figure}
 \centering
 \includegraphics[width=\textwidth]{pdfs/Terminatable}
 \caption{The Terminatable aspect}
\end{figure}


\subsubsection{OutcomeVotable}

\textit{OutcomeVotable} depends on \textit{Terminatable} and the \textit{OutcomeAware} aspect of the original AspectOPTIMA framework in order to make it possible to vote on the outcome of a transaction upon leaving its context. The aspect automatically terminates a context once its outcome is decided. The structural view shows that we only added the methods \textit{registerVote}, \textit{computeOutcome} and \textit{isOutcomeDecided} as well as a relation \textit{votes} to the complete class \textit{Outcome} to \textit{OutcomeVotableContext}. The message view for the method \textit{voteAndLeaveContext}, that is already provided by \textit{OutcomeAware}, illustrates that we simply register the provided vote prior to leaving the context. The functionality for \textit{registerVote} as shown in its message view is to add the vote to the current votes and to check whether the outcome is already decided. If this is the case the outcome is computed and set before we finally terminate the context.  

% DONE change setOutcome(decided) to setOutcome(outcome) and move outcome :=  prior to it
% DONE add votes relation to Outcome to structural view

\begin{figure}[th!]
 \centering
 \includegraphics[width=\textwidth]{pdfs/OutcomeVotable}
 \caption{The OutcomeVotable aspect}
\end{figure}

\subsubsection{OutcomeVoting}

The aspect \textit{OutcomeVoting} makes sure that every participant that leaves a context automatically votes on its outcome by using the functionality of \textit{OutcomeVotable}. The concise structural view shows that we added only one method \textit{getDefaultVote} that provides us with the default voting behavior. The modification of \textit{leaveContext} as show in its message view uses this method and registers the corresponding vote prior to leaving the context.

% DONE standard before

\begin{figure}[th!]
 \centering
 \includegraphics[width=\textwidth]{pdfs/OutcomeVoting}
 \caption{The OutcomeVoting aspect}
\end{figure}

\subsubsection{SpawnSupporting}

\textit{SpawnSupporting} gives a context participant the possibility to spawn further participants that automatically participate in its context thereafter. We define the methods \textit{getSpawnedParticipantCount} and \textit{increaseSpawnedParticipantCount} for \textit{SpawnSupportingContext} in the structural view and introduce \textit{createNewParticipant}, \textit{spawnParticipant}, \textit{isSpawned} and \textit{setToSpawned} to \textit{SpawnSupportingParticipant}. In the state view of \textit{SpawnSupportingParticipant} we simply add a new transition from \textit{Idle} to \textit{Creating} to account for the possibility of spawned participants. The detailed behavior of spawning a participant is illustrated in the message view of \textit{spawnParticipant}: after creating the new participant we mark it as spawned and increase the number of spawned participants accordingly. Finally we make the spawned participant enter the same context as the participant that spawned it.

% DONE change createParticipant to package

% DONE add and use increaseSpawnedParticipantCount

\begin{figure}[th!]
 \centering
 \includegraphics[width=\textwidth]{pdfs/SpawnSupporting}
 \caption{The SpawnSupporting aspect}
\end{figure}

\subsubsection{OpenMultithreadedTransaction}

The \textit{OpenMultithreadedTransaction} aspect combines all the functionality provided by the other aspects of our framework into one aspect and contains no own additional logic or structure. Everything that is left to do at this point is to instantiate and to bind the elements of the reused aspects.

\subsection{Conflict Resolutions}

As the combination of different aspects may result in conflicting behavior RAM offers the possibility to detect and resolve such conflicts. Our Open Multithreaded Transactions model contains three conflict resolution aspects that coordinate the interaction between two existing aspects each.

\subsubsection{Conflict resolution: Nested / Collaborative}

The conflict resolution aspect \textit{Nested / Collaborative} automatically applies whenever a \textit{CollaborativeContext} is also a \textit{NestedContext}. It replaces the message view for \textit{Collaborative.isAllowedToJoin} in order to allow a participant that is already associated to a context to join another context if the latter is a direct or indirect parent of the previous. In order to achieve this behavior the current context is checked and if it is not null a while loop is used in order to iterate over the ancestors until the context that should be joined is found. If this context is not found before an ancestor that has no parent is reached, the while loop ends and the method returns the unchanged false result.

% DONE rename p := to parent :=
% DONE add result ;= false to beginning

\begin{figure}[th!]
 \centering
 \includegraphics[width=\textwidth]{pdfs/Conflict_NestedCollaborative}
 \caption{The conflict resolution aspect for Nested and Collaborative}
\end{figure}

\subsubsection{Conflict resolution: ExitSynchronizing / SpawnSupporting}

In order to allow spawned participants of the \textit{SpawnSupporting} aspect to leave a context without being blocked in presence of the \textit{ExitSynchronizing} aspect we modeled a conflict resolution aspect \textit{ExitSynchronizing / SpawnSupporting}. The message view for \textit{ExitSynchronizing.leaveContext} is modified in order to check whether a participant is spawned or not. For participants that have not been spawned it proceeds with the original blocking behavior whereas spawned participants are treated with a call to \textit{Collaborative}'s \textit{leaveContext} functionality without exit synchronizing.
% TODO !!!!!! <<call>> ?????!!!!!
% TODO -> fully qualified name unnecessary as both conflict parts are merged
% DONE include ExitSynchronizing.leaveContext and change condition to blocked = participants.size - spawned

\begin{figure}[th!]
 \centering
 \includegraphics[width=\textwidth]{pdfs/Conflict_ExitSynchronizingSpawnSupporting}
 \caption{The conflict resolution aspect for ExitSynchronizing and SpawnSupporting}
\end{figure}

\subsubsection{Conflict resolution: Closable / SpawnSupporting}

The conflict resolution aspect \textit{Closable / SpawnSupporting} ensures that spawned participants can still be added to a context even if it is closed and it excludes spawned participants from the condition for the automatic closing of a context. The first modification is achieved by adding the condition \textit{or p.isSpawned()} to the transitions for \textit{addParticipant} in \textit{ClosableContext}'s state view. The second modification is accomplished by retrieving the number of spawned participants and subtracting it from the number of participants in the comparison condition of the message view for \textit{Closable.addParticipant}.

\begin{figure}[th!]
 \centering
 \includegraphics[width=\textwidth]{pdfs/Conflict_ClosableSpawnSupporting}
 \caption{The conflict resolution aspect for Closable and SpawnSupporting}
\end{figure}

\section{Related Work}

A multitude of different transaction systems have been developed and used since the early 1980s but only few explicitly provide functionality for cooperation between different transactions. A detailed overview and historical treatment of transaction management as in \cite{HistTransManag} is beyond the scope of this paper but we want to point out some interesting work that influenced the development of OMTT. CORBA's unrestricted support for multithreaded transactions had a big influence on the authors of OMTT and they tried to overcome lots of its shortcomings and even ported their transaction model to CORBA \cite{OMTTCORBA}.
Coordinated Atomic (CA) actions \cite{CA} are rather a structuring technique for atomic actions that was augmented with support for transactions than a transaction management system. Nevertheless they let participants join CA actions, isolate their transactional objects and coordinate exception handling. This participation is however tightly coupled, relies on explicit synchronization and does not allow the creation and termination of participants within transactions. 
Enterprise Java Beans is a widely used implementation framework with support for transactions that provides only restricted support for multithreaded transactions but is always subject to improvements and ongoing research \cite{EJB}. This and a lot of other approaches are very implementation centered as opposed to OMTT but they nevertheless provide interesting ideas like workspace merging in \cite{CAM}.


% \subsection{Aspectual Decomposition of Transactions}
% 
% \subsection{Open Multithreaded Transactions: A transaction model for concurrent object-oriented programming}

\section{Future Work \& Conclusions}

\subsection{Future Work}

Exception handling is an integral part of Open Multithreaded Transactions that is critical for transaction management but exceptions where neither modeled in AspectOPTIMA nor in its OMTT extension. A separate model of exceptional behavior that does not obfuscate the original behavior or add accidental complexity is not yet supported by RAM. Adding adequate constructs and views to Reusable Aspect Models and evaluating them using the extended AspectOPTIMA case study could be an important and interesting field for future research.

Although AspectOPTIMA provides support for different concurrency and recovery mechanisms our model of OMTT does not leverage these possibilities yet. Future work could sustain this variation possibilities throughout the OMTT extension or even add new variation points and facilitate their use by employing RAMs constructs for configuration support. In the meantime new constructs that include variation possibilities directly into RAM's structural, state or message views could be investigated and be combined with the existing feature diagram mechanism.

A last field for future work could be a concrete implementation of OMTT that evaluates our model and shows where details are missing or behavior should be refined prior to implementation. It could also serve as a proof of efficiency and correctness of our model and provide a case study for aspect-oriented programming.

\subsection{Conclusions}

This undergraduate research project was able to continue previous work on transaction systems and can be used as an extension to the initial AspectOPTIMA case study. It illustrates the features and advantages of Reusable Aspect Models and was the inspiration for minor changes to this aspect-oriented modeling approach. The resulting model of OMTT can serve as a case study for aspect-oriented software development and the lessons learned from this project stimulated our interest in this field of study. The project's results yield various possibilities for future work on RAM and can serve as a basis for an aspect-oriented implementation of OMTT.

\newpage

\begin{spacing}{0.95	}
\bibliographystyle{plain}
\bibliography{AspectOPTIMA_OMTT_report}
\end{spacing}

\end{document}
